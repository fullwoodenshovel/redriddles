if i want to access functions other than just the ones outlined in the trait, but it differs per struct, can i use downcasting? if so, how?

Yes â€” this is exactly when downcasting is correct, and Rust gives you a clean, safe way to do it.

This is not a hack.
This is how every serious Rust UI framework handles â€œescape hatchesâ€.

ğŸ§  The rule

Use the trait for common behavior
Use downcasting for type-specific behavior

ğŸ§± Step 1 â€” make Widget downcastable
use std::any::Any;

pub trait Widget {
    fn as_any(&self) -> &dyn Any;
    fn as_any_mut(&mut self) -> &mut dyn Any;

    fn update(&mut self, node: &UiNode, input: &UserInputs);
    fn draw(&self, node: &UiNode);
}

ğŸ§© Step 2 â€” implement it for every widget
impl Widget for Button {
    fn as_any(&self) -> &dyn Any { self }
    fn as_any_mut(&mut self) -> &mut dyn Any { self }

    fn update(&mut self, node: &UiNode, input: &UserInputs) { /* ... */ }
    fn draw(&self, node: &UiNode) { /* ... */ }
}


Do the same for every widget type.

ğŸ” Step 3 â€” downcast when needed
if let Some(button) = node.borrow_mut().widget.as_any_mut().downcast_mut::<Button>() {
    button.set_color(Color::Red);
}


This is:

Fully type-safe

Zero UB

Runtime-checked

ğŸ”„ Example: sibling widget control
let parent = node.borrow().parent.as_ref().and_then(|p| p.upgrade()).unwrap();

for sibling in &parent.borrow().children {
    if let Some(picker) = sibling.borrow_mut()
        .widget
        .as_any_mut()
        .downcast_mut::<ColourPicker>() 
    {
        picker.set_colour(Color::Blue);
    }
}

âš ï¸ When downcasting is a code smell

If you find yourself downcasting constantly:

node.widget.as_any_mut().downcast_mut::<A>()
node.widget.as_any_mut().downcast_mut::<B>()
node.widget.as_any_mut().downcast_mut::<C>()


That means the functionality should move into the trait.

ğŸ Summary
Use case	Tool
Shared UI behavior	trait Widget
Type-specific escape hatch	as_any_mut().downcast_mut::<T>()
Parent/child access	UiNode
Avoid over-downcasting	Promote to trait method

This gives you flexibility without sacrificing architecture.

how does downcasting work? surely the whole point is that you cant convince the compiler that it is the type you want it to be, so how does it convince the compiler? is it runtime? if so, does it error if it is of the wrong type?

This is one of the most important â€œhow Rust actually works under the hoodâ€ questions you can ask.
Letâ€™s demystify it properly.

ğŸ”‘ Short answer

Downcasting in Rust is:

100% runtime

Type-safe

Never causes UB

Never lies to the compiler

Fails cleanly with None

The compiler is not convinced.
It is checked at runtime using real type identity.

ğŸ§  What problem downcasting solves

When you write:

let w: Box<dyn Widget> = Box::new(Button {});


You have erased the concrete type.
At compile time, w is just:

dyn Widget


The compiler does not know it is a Button.

ğŸ§© What Any does

Rust secretly stores a TypeId inside every 'static value implementing Any.

use std::any::{Any, TypeId};


Every concrete type has a unique TypeId generated by the compiler.

ğŸ”¬ What actually happens when you downcast

When you call:

widget.as_any_mut().downcast_mut::<Button>()


Rust does this internally:

Read the hidden TypeId of the value

Compare it with TypeId::of::<Button>()

If equal â†’ reinterpret pointer as &mut Button

If not â†’ return None

No guessing.
No magic.
Just pointer comparison.

ğŸ§¯ What happens on failure?

Nothing bad.

if let Some(btn) = widget.as_any_mut().downcast_mut::<Button>() {
    btn.click();
}


If it is not a Button:

Returns None

Your code inside the if let never runs

Program continues safely

No panic.
No UB.
No lies.

ğŸš¨ Why Rust forces you to use Any

This is illegal:

let b: &Button = unsafe { std::mem::transmute(&*widget) };


This is lying to the compiler and is UB.

Any exists specifically so Rust can offer:

Runtime type inspection without breaking memory safety

ğŸ§¬ Why 'static is required

The type identity system only works if the value:

Will never move

Has no borrowed data inside

So Any only works on 'static types.

This is a safety guarantee, not a limitation.

ğŸ Summary
Property	Downcasting
Compile-time?	âŒ No
Runtime?	âœ… Yes
Unsafe?	âŒ No
UB possible?	âŒ No
Wrong type behavior	Returns None
Mechanism	TypeId equality

Downcasting does not convince the compiler.

It asks the program at runtime:

â€œAre you really a Button?â€

And only proceeds if the answer is provably yes.

when is a trait not dyn compatible and why is it that way?

This is a deep Rust topic, but it has a very clean rule once you see the model.

A trait is not dyn-compatible (often called not object-safe) when the compiler cannot build a valid vtable call interface for it.

Letâ€™s decode that.

ğŸ§  What dyn Trait really is

When you write:

let w: Box<dyn Widget>


Rust stores:

[data pointer] + [vtable pointer]


The vtable is literally:

struct VTable {
    draw: fn(*const (), ...),
    update: fn(*mut (), ...),
    drop: fn(*mut ()),
}


Every method in the trait must be callable using:

fn(this: *mut (), args...)


If Rust cannot generate such a function pointer, the trait is not dyn-compatible.

âŒ Rule 1 â€” Methods returning Self
trait Bad {
    fn clone(&self) -> Self;
}


Why impossible?

If you have dyn Bad, the compiler has no idea what Self is at runtime.

What would the return type be?

âŒ Rule 2 â€” Generic methods
trait Bad {
    fn draw<T>(&self, t: T);
}


Why impossible?

The vtable must contain concrete function pointers.

But generics mean the function only exists after monomorphization â€” which requires knowing the concrete type at compile time.

With dyn Trait, there is no concrete type.

âŒ Rule 3 â€” Methods with where Self: Sized
trait Bad {
    fn new() -> Self where Self: Sized;
}


This is explicitly saying:

â€œThis method only exists when the type is known.â€

So Rust refuses to put it in a vtable.

âŒ Rule 4 â€” Associated constants / types used in method signatures
trait Bad {
    type Item;
    fn get(&self) -> Self::Item;
}


Why impossible?

dyn Bad does not know what Item is.
There is no runtime representation for associated types.

âŒ Rule 5 â€” Taking Self by value
trait Bad {
    fn consume(self);
}


Why impossible?

The vtable call would require knowing the size of Self, but dyn Trait is unsized.

âŒ Rule 6 â€” Supertraits with generic methods

If your trait inherits from a non-object-safe trait, it becomes non-object-safe too.

âœ… What is dyn-compatible
trait Good {
    fn draw(&self);
    fn update(&mut self, input: &Input);
}


Why?

Because Rust can generate:

fn(*mut (), &Input)


for every method.

ğŸ§¬ The rule in one sentence

A trait is dyn-compatible if and only if every method can be called through a *mut () with a fixed concrete signature.

If the compiler cannot generate a fixed function pointer for the method, the trait cannot be made into dyn Trait.

ğŸ Mental model
Feature	dyn-compatible?	Reason
fn(&self)	âœ…	Known size
fn(&mut self)	âœ…	Known size
fn(self)	âŒ	Needs size
fn<T>(&self, T)	âŒ	Needs monomorphization
fn() -> Self	âŒ	Unknown return type
Associated types	âŒ	No runtime representation

Once you understand the vtable pointer model, object safety becomes inevitable â€” not arbitrary.